#include <memory> // for allocator, shared_ptr, __shared_ptr_access
#include <string> // for char_traits, operator+, to_string

#include "ftxui/component/captured_mouse.hpp" // for ftxui
#include "ftxui/component/component.hpp"      // for Slider, Renderer, Vertical
#include "ftxui/component/component_base.hpp" // for ComponentBase
#include "ftxui/component/screen_interactive.hpp" // for ScreenInteractive
#include "ftxui/dom/elements.hpp" // for separator, operator|, Element, size, text, vbox, xflex, bgcolor, hbox, GREATER_THAN, WIDTH, border, HEIGHT, LESS_THAN
#include "ftxui/screen/color.hpp" // for Color

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <chrono>
#include <iomanip>
#include <iostream>
#include <string>
#include <thread>

#include "can_wrap.hpp"
#include "candata.h"
using can::operator<<;
using namespace ftxui;

Element Display(int batV, int frontL, int frontR, int rearL, int rearR,
                int torqueF, int torqueR) {
  return text(
      "Battery Voltage = " + std::to_string(batV) + "\n" +               //
      "Wheel Speeds \n" + "Front Left" + std::to_string(frontL) + "\n" + //
      "Front Right" + std::to_string(frontR) + "\n" + "Rear Left" +
      std::to_string(rearL) + "\n" + "Rear Right" + std::to_string(rearR) +
      "\n" + "Requested Torque \n" + "Front = " + std::to_string(torqueF) +
      "\n" + "Rear = " + std::to_string(torqueR) + "\n" //
  );
}

/*Autogenerated Code from the DBC file
Packs the given value into CAN frame ,
@param value:Variable that stores the value to be packed in the frame
@param shift: Number of bytes to be shifted by
@param mask: Bit mask thats ANDed with the input*/

static inline uint8_t pack_left_shift_u16(uint16_t value, uint8_t shift,
                                          uint8_t mask) {
  return (uint8_t)((uint8_t)(value << shift) & mask);
}

/*Autogenerated Code from the DBC file
Packs the given value into CAN frame ,
@param value:Variable that stores the value to be packed in the frame
@param shift: Number of bytes to be shifted by
@param mask: Bit mask thats ANDed with the input*/

static inline uint8_t pack_right_shift_u16(uint16_t value, uint8_t shift,
                                           uint8_t mask) {
  return (uint8_t)((uint8_t)(value >> shift) & mask);
}

/* @param signame : Input
   @param value : Buffer to store the input from the user
   @param binvalue: function returns this value */
uint16_t getinputs(char signame) {
  std::string signalname;
  switch (signame) {
  case 'a':
    signalname = "Battery Voltage(0 to 13)";
    break;

  case 'b':
    signalname = "Speed of Front Left Wheel(0 to 65535)";
    break;

  case 'c':
    signalname = "Speed of Front Right Wheel(0 to 65535)";
    break;

  case 'd':
    signalname = "Speed of Rear Left Wheel(0 to 65535)";
    break;

  case 'e':
    signalname = "Speed of Rear Right Wheel(0 to 65535)";
    break;

  case 'f':
    signalname = "Requested Torque for Front(-32768 to 32767)";
    break;

  case 'g':
    signalname = "Requested Torque for Rear(-32768 to 32767)";
    break;

  default:
    break;
  }
  uint16_t value;
  uint16_t binvalue;
  std::cout << "Please enter the " << signalname << std::endl;
  std::cin >> value;
  binvalue = value;
  return binvalue;
}

/*@param ---> battVolt: Batery voltage
  @param ---> Battery: structure that stores the voltage values*/
void get_dataBatt(int battVolt, struct candata_vcu_battery_t *battery) {
  // function to create structure of the data for battery
  battery->voltage = battVolt;
  size_t batSize = 2;
}

/* @param : ---> FL: Speed of the front left wheel
   @param : ---> FR: Speed of the front right wheel
   @param : ---> RL: Speed of the rear left wheel
   @param : ---> RR: Speed of the rear right wheel
   @param : ---> speed: Structure to store the values of in */
void get_dataSpeed(uint16_t FL, uint16_t FR, uint16_t RL, uint16_t RR,
                   struct candata_vcu_wheel_speeds_t *speed) {
  speed->fl_wheel_speed = FL;
  speed->fr_wheel_speed = FR;
  speed->rl_wheel_speed = RL;
  speed->rr_wheel_speed = RR;
}

/*
   @param : ---> TF: Requested torque of the front wheels
   @param : ---> TR: Requested torque of the rear wheels
   @param : ---> torque: Structure to store the values of in */
void get_dataTorque(int16_t TF, int16_t TR, int16_t steer,
                    struct candata_ai_drive_request_t *torque) {
  torque->front_trq_request = TF;
  torque->rear_trq_request = TR;
  torque->steering_request = steer;
}
int main(int argc, char *argv[]) {
  const std::string canChannel = "vcan0";
  const int canSocket = can::connect(canChannel);

  // data inputs and structure for battery voltage
  int bat = getinputs('a');
  struct candata_vcu_battery_t battery;

  // data inputs and structure for speeds
  int speedFL = getinputs('b');
  int speedFR = getinputs('c');
  int speedRL = getinputs('d');
  int speedRR = getinputs('e');
  struct candata_vcu_wheel_speeds_t speed;

  // data inputs and structure for requested torque

  int torqueF = getinputs('f');
  int torqueR = getinputs('g');
  int steering = 0;
  struct candata_ai_drive_request_t torque;

  while (true) {
    // canframe defination for battery voltage
    can_frame Battery;
    std::memset(&Battery, 0, sizeof(Battery));
    get_dataBatt(bat, &battery);
    Battery.can_id = 0x526;
    Battery.can_dlc = 2;
    Battery.data[0] = pack_right_shift_u16(battery.voltage, 8u, 0xffu);
    Battery.data[1] = pack_left_shift_u16(battery.voltage, 0u, 0xffu);

    // canframe defination for wheel speeds
    can_frame Speeds;
    std::memset(&Speeds, 0, sizeof(Speeds));
    Speeds.can_id = 0x525;
    Speeds.can_dlc = 8;
    get_dataSpeed((uint16_t)speedFL, (uint16_t)speedFR, (uint16_t)speedRL,
                  (uint16_t)speedRR, &speed);
    Speeds.data[0] = pack_right_shift_u16(speed.fl_wheel_speed, 8u, 0xffu);
    Speeds.data[1] = pack_left_shift_u16(speed.fl_wheel_speed, 0u, 0xffu);
    Speeds.data[2] = pack_right_shift_u16(speed.fr_wheel_speed, 8u, 0xffu);
    Speeds.data[3] = pack_left_shift_u16(speed.fr_wheel_speed, 0u, 0xffu);
    Speeds.data[4] = pack_right_shift_u16(speed.rl_wheel_speed, 8u, 0xffu);
    Speeds.data[5] = pack_left_shift_u16(speed.rl_wheel_speed, 0u, 0xffu);
    Speeds.data[6] = pack_right_shift_u16(speed.rr_wheel_speed, 8u, 0xffu);
    Speeds.data[7] = pack_left_shift_u16(speed.rr_wheel_speed, 0u, 0xffu);

    // canframe definaion for torque
    can_frame Torque;
    std::memset(&Torque, 0, sizeof(Torque));
    Torque.can_id = 0x521;
    Torque.can_dlc = 6;
    get_dataTorque((int16_t)torqueF, (int16_t)torqueR, (int16_t)steering,
                   &torque);
    Torque.data[0] = pack_right_shift_u16(torque.front_trq_request, 8u, 0xffu);
    Torque.data[1] = pack_left_shift_u16(torque.front_trq_request, 0u, 0xffu);
    Torque.data[2] = pack_right_shift_u16(torque.steering_request, 8u, 0xffu);
    Torque.data[3] = pack_left_shift_u16(torque.steering_request, 0u, 0xffu);
    Torque.data[4] = pack_right_shift_u16(torque.rear_trq_request, 8u, 0xffu);
    Torque.data[5] = pack_left_shift_u16(torque.rear_trq_request, 0u, 0xffu);

    try {
      // std::cout << RPM << torque << std::endl;
      std::cout << Battery << std::endl;
      can::write(canSocket, Battery);

      std::cout << Speeds << std::endl;
      can::write(canSocket, Speeds);

      std::cout << Torque << std::endl;
      can::write(canSocket, Torque);

    } catch (const std::runtime_error &e) {
      std::cerr << e.what() << std::endl;
    }

    std::this_thread::sleep_for(std::chrono::seconds(1));
  }

  can::close(canSocket);

  return 0;

  // GUI code

  /*auto slider_1 = Slider("Battery Voltage  :", &bat, 0, 13, 1);
  auto slider_2 = Slider("Speed Front Left :", &speedFL, -65535, 65535, 10);
  auto slider_3 = Slider("Speed Front Right:", &speedFR, -65535, 65535, 10);
  auto slider_4 = Slider("Speed Rear Left  :", &speedRL, -65535, 65535, 10);
  auto slider_5 = Slider("Speed Rear Right :", &speedRR, -65535, 65535, 10);
  auto slider_6 = Slider("Front Torque     :", &torqueF, -32768, 32767, 10);
  auto slider_7 = Slider("Rear Torque      :", &torqueR, -32768, 32767, 10);

   auto container = Container::Vertical({
    slider_1,
    slider_2,
    slider_3,
    slider_4,
    slider_5,
    slider_6,
    slider_7,
});

  auto renderer = Renderer(container, [&] {
  return hbox({
             //ColorTile(red, green, blue),
             separator(),
             vbox({
                 slider_1->Render(),
                 separator(),
                 slider_2->Render(),
                 separator(),
                 slider_3->Render(),
                 separator(),
                 slider_4->Render(),
                 separator(),
                 slider_5->Render(),
                 separator(),
                 slider_6->Render(),
                 separator(),
                 slider_7->Render(),
                 separator(),
                 Display (bat, speedFL,
speedFR,speedRL,speedRR,torqueF,torqueR),
             }) | xflex,
         }) |
         border | size(WIDTH, LESS_THAN, 80);
});
auto screen = ScreenInteractive::TerminalOutput();
screen.Loop(renderer);*/
}

#define CATCH_CONFIG_MAIN
#include <catch.hpp>
#include <cstdint>

// Code to be tested
#include <memory> // for allocator, shared_ptr, __shared_ptr_access
#include <string> // for char_traits, operator+, to_string

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <chrono>
#include <iomanip>
#include <iostream>
#include <string>
#include <thread>

#include "can_wrap.hpp"
#include "candata.h"
using can::operator<<;

const std::string canChannel = "vcan0";
const int canSocket = can::connect(canChannel);

uint16_t batteryvoltage;  // battery voltage
uint16_t frontleftspeed;  // speed of the front left wheel
uint16_t frontrightspeed; // speed of the front right wheel
uint16_t rearleftspeed;   // speed of the rear left wheel
uint16_t rearrightspeed;  // speed of the rear right wheel
uint16_t fronttorque;     // requested torque for the front wheels
uint16_t reartorque;      // requested torque for the rear wheels
_Float32 frontcurrent;    // calculated current for the front wheels
_Float32 rearcurrent;     // calculated current for the rear wheels
uint16_t maxtorquefront;  // maximum allowed torque for the front wheels
uint16_t maxtorquerear;   // maximum allowed torque for the rear wheels

/*Autogenerated Code from the DBC file
Packs the given value into CAN frame ,
@param value:Variable that stores the value to be packed in the frame
@param shift: Number of bytes to be shifted by
@param mask: Bit mask thats ANDed with the input*/
static inline uint8_t pack_left_shift_u16(uint16_t value, uint8_t shift,
                                          uint8_t mask) {
  return (uint8_t)((uint8_t)(value << shift) & mask);
}

/*Autogenerated Code from the DBC file
Packs the given value into CAN frame ,
@param value:Variable that stores the value to be packed in the frame
@param shift: Number of bytes to be shifted by
@param mask: Bit mask thats ANDed with the input*/
static inline uint8_t pack_right_shift_u16(uint16_t value, uint8_t shift,
                                           uint8_t mask) {
  return (uint8_t)((uint8_t)(value >> shift) & mask);
}

/*Autogenerated Code from DBC file
Takes data frame as a input and deocode it from HEX to Decimal value */
static inline uint16_t unpack_left_shift_u16(uint8_t value, uint8_t shift,
                                             uint8_t mask) {
  return (uint16_t)((uint16_t)(value & mask) << shift);
}

/*Autogenerated Code from DBC file
Takes data frame as a input and deocode it from HEX to Decimal value */
static inline uint16_t unpack_right_shift_u16(uint8_t value, uint8_t shift,
                                              uint8_t mask) {
  return (uint16_t)((uint16_t)(value & mask) >> shift);
}

/* Takes two parameters
@param a,b - inputs
@return - Max of the two inputs*/
uint16_t maxof(int16_t a, int16_t b) {
  if (a > b)
    return a;
  else
    return b;
}

/* Takes two parameters
@param a,b - inputs
@return - Min of the two inputs*/
uint16_t minof(int16_t a, int16_t b) {
  if (a < b)
    return a;
  else
    return b;
}

/*Reconstructs the value of the battery voltage from the CAN frame
Also checks whether the value of the parameter is within the limits from the DBC
file
@param frame : input can frame read from the CAN channel
@param batteryvoltage : stores the decodes value of battery voltage
*/
uint16_t batteryframe(const can_frame frame) {
  batteryvoltage = static_cast<uint16_t>(frame.data[0] << 8) +
                   static_cast<uint16_t>(frame.data[1]);

  if (batteryvoltage > 13) {
    std::cout << "Battery Voltage value Out of Range" << std::endl;
    return 1;
  }

  return 0;
}

/*Reconstructs the value of the wheel speeds from the CAN frame
Also checks whether the value of the parameter is within the limits from the DBC
file
@param frame : input can frame read from the CAN channel
@param frontleftspeed : stores the decodes value of speed for the front left
wheel
@param frontrightspeed : stores the decodes value of speed for the front right
wheel
@param rearleftspeed : stores the decodes value of speed for the rear left wheel
@param rearrightspeed : stores the decodes value of speed for the rear right
wheel
*/
uint16_t speedframe(const can_frame frame) {
  frontleftspeed = static_cast<uint16_t>(frame.data[0] << 8) +
                   static_cast<uint16_t>(frame.data[1]);

  frontrightspeed = static_cast<uint16_t>(frame.data[2] << 8) +
                    static_cast<uint16_t>(frame.data[3]);

  rearleftspeed = static_cast<uint16_t>(frame.data[4] << 8) +
                  static_cast<uint16_t>(frame.data[5]);

  rearrightspeed = static_cast<uint16_t>(frame.data[6] << 8) +
                   static_cast<uint16_t>(frame.data[7]);

  if (frontleftspeed > 65535 || frontrightspeed > 65535 ||
      rearleftspeed > 65535 || rearrightspeed > 65535) {
    std::cout << "One of the Wheel speed value is Out of Range" << std::endl;
    return 1;
  }

  return 0;
}

/*Reconstructs the value of the requested torque from the CAN frame
Also checks whether the value of the parameter is within the limits from the DBC
file
@param frame : input can frame read from the CAN channel
@param fronttorque : stores the decoded value of requested torque for the front
wheels
@param reartorque : stores the decoded value of requested torque for the rear
wheels
*/
int16_t torqueframe(const can_frame frame) {
  fronttorque = unpack_left_shift_u16(frame.data[0], 8u, 0xffu) +
                unpack_right_shift_u16(frame.data[1], 0u, 0xffu);

  reartorque = unpack_left_shift_u16(frame.data[4], 8u, 0xffu) +
               unpack_right_shift_u16(frame.data[5], 0u, 0xffu);

  // std::cout<<"Front torque is "<<fronttorque<<std::endl;
  // std::cout<<"Rear Torque "<<reartorque<<std::endl;

  if (fronttorque > 32767 || fronttorque < -32768 || reartorque > 32767 ||
      reartorque < -32768) {
    std::cout << "One of the Torque Request is Out of Range" << std::endl;
    return 1;
  }

  return 0;
}

/*calculates the current based on the input parameters
Also determines the max torque limit for the wheels based on the speeds of the
wheel*/
void currentcal() {
  uint16_t frontwheelspeed =
      maxof(frontleftspeed,
            frontrightspeed); // the speed for the front wheel which is max of
                              // the speeds for the two wheels
  uint16_t rearwheelspeed = maxof(
      rearleftspeed, rearrightspeed); // the speed for the rear wheel which is
                                      // max of the speeds for the two wheels
  _Float32 qfactor = 0.879;
  _Float32 BEFF = 0.6721;

  if (frontwheelspeed > 700) {
    maxtorquefront = 50;
  } else if (frontwheelspeed > 600) {
    maxtorquefront = 85;
  } else if (frontwheelspeed > 500) {
    maxtorquefront = 100;
  } else if (frontwheelspeed > 400) {
    maxtorquefront = 120;
  } else if (frontwheelspeed > 300) {
    maxtorquefront = 150;
  } else {
    maxtorquefront = 32767;
  }

  if (rearwheelspeed > 700) {
    maxtorquerear = 50;
  } else if (rearwheelspeed > 600) {
    maxtorquerear = 85;
  } else if (rearwheelspeed > 500) {
    maxtorquerear = 100;
  } else if (rearwheelspeed > 400) {
    maxtorquerear = 120;
  } else if (rearwheelspeed > 300) {
    maxtorquerear = 150;
  } else {
    maxtorquerear = 32767;
  }

  if (batteryvoltage < 2.8) {
    maxtorquefront = 20;
    maxtorquerear = 20;
  }

  // std::cout<<"Max Torque front = "<<maxtorquefront<<std::endl;
  // std::cout<<"Max torque Rear = "<<maxtorquerear<<std::endl;

  int16_t fronttorqueactual = minof(fronttorque, maxtorquefront);
  int16_t reartorqueactual = minof(reartorque, maxtorquerear);

  // std::cout<<"Actual Torque front = "<<fronttorqueactual<<std::endl;
  // std::cout<<"Actual torque Rear = "<<reartorqueactual<<std::endl;

  frontcurrent = (fronttorqueactual / batteryvoltage) *
                 (1 + (qfactor * qfactor * (fronttorqueactual / 100)) +
                  (frontwheelspeed * (BEFF / 100) * fronttorqueactual));
  rearcurrent = (reartorqueactual / batteryvoltage) *
                (1 + (qfactor * qfactor * (reartorqueactual / 100)) +
                 (rearwheelspeed * (BEFF / 100) * reartorqueactual));
}

/*@param frame: Input can frame read from the can channel
Identifies the type of the frame based on the can frame id and the sends the
frame to neccesary function to decode the value */
void process_frame(const can_frame frame) {
  switch (frame.can_id) {
  case 0x526:
    batteryframe(frame);
    break;

  case 0x525:
    speedframe(frame);
    break;

  case 0x521:
    torqueframe(frame);
    break;

  default:
    break;
  }
}

// Test code

int storeV;
can_frame testframe;
TEST_CASE("Baterry Voltage in range") {
  SECTION("Applying the Mid Value") {
    testframe.can_dlc = 2;
    testframe.data[0] = 0x00;
    testframe.data[1] = 0x07;
    storeV = batteryframe(testframe);
    REQUIRE(batteryvoltage == 7);
    REQUIRE(storeV == 0);
  }

  SECTION("Appying Minimum value") {
    testframe.data[0] = 0x00;
    testframe.data[1] = 0x00;
    storeV = batteryframe(testframe);
    REQUIRE(batteryvoltage == 0);
    REQUIRE(storeV == 0);
  }

  SECTION("Applying the Maximum Value") {
    testframe.data[0] = 0x00;
    testframe.data[1] = 0x0D;
    storeV = batteryframe(testframe);
    REQUIRE(batteryvoltage == 13);
    REQUIRE(storeV == 0);
  }
}

TEST_CASE("Battery Voltage out of range") {
  testframe.data[0] = 0x0A;
  testframe.data[1] = 0x0A;
  storeV = batteryframe(testframe);
  REQUIRE(batteryvoltage == 2570);
  REQUIRE(storeV == 1);
}

TEST_CASE("Wheel Speeds in the range") {
  SECTION("Applying the Mid Value") {
    testframe.data[0] = 0x01;
    testframe.data[1] = 0xF4;
    testframe.data[2] = 0x01;
    testframe.data[3] = 0xF4;
    testframe.data[4] = 0x01;
    testframe.data[5] = 0xF4;
    testframe.data[6] = 0x01;
    testframe.data[7] = 0xF4;
    storeV = speedframe(testframe);
    REQUIRE(frontleftspeed == 500);
    REQUIRE(frontrightspeed == 500);
    REQUIRE(rearleftspeed == 500);
    REQUIRE(rearrightspeed == 500);
    REQUIRE(storeV == 0);
  }

  SECTION("Applying Minimum Value") {
    testframe.data[0] = 0x00;
    testframe.data[1] = 0x00;
    testframe.data[2] = 0x00;
    testframe.data[3] = 0x00;
    testframe.data[4] = 0x00;
    testframe.data[5] = 0x00;
    testframe.data[6] = 0x00;
    testframe.data[7] = 0x00;
    storeV = speedframe(testframe);
    REQUIRE(frontleftspeed == 0);
    REQUIRE(frontrightspeed == 0);
    REQUIRE(rearleftspeed == 0);
    REQUIRE(rearrightspeed == 0);
    REQUIRE(storeV == 0);
  }

  SECTION("Applying the Maximum Values") {
    testframe.data[0] = 0xFF;
    testframe.data[1] = 0xFF;
    testframe.data[2] = 0xFF;
    testframe.data[3] = 0xFF;
    testframe.data[4] = 0xFF;
    testframe.data[5] = 0xFF;
    testframe.data[6] = 0xFF;
    testframe.data[7] = 0xFF;
    storeV = speedframe(testframe);
    REQUIRE(frontleftspeed == 65535);
    REQUIRE(frontrightspeed == 65535);
    REQUIRE(rearleftspeed == 65535);
    REQUIRE(rearrightspeed == 65535);
    REQUIRE(storeV == 0);
  }
}

TEST_CASE("TORQUE Values in Range") {

  SECTION("Applying the Mid Values") {
    testframe.data[0] = 0x00;
    testframe.data[1] = 0x64;
    testframe.data[2] = 0x00;
    testframe.data[3] = 0x00;
    testframe.data[4] = 0x00;
    testframe.data[5] = 0x64;
    storeV = torqueframe(testframe);
    REQUIRE(fronttorque == 100);
    REQUIRE(reartorque == 100);
    REQUIRE(storeV == 0);
  }

  SECTION("Applying the Maximum Values") {
    testframe.data[0] = 0x7F;
    testframe.data[1] = 0xFF;
    testframe.data[2] = 0x00;
    testframe.data[3] = 0x00;
    testframe.data[4] = 0x7F;
    testframe.data[5] = 0xFF;
    storeV = torqueframe(testframe);
    REQUIRE(fronttorque == 32767);
    REQUIRE(reartorque == 32767);
    REQUIRE(storeV == 0);
  }
}

TEST_CASE("TORQUE Values are out of range") {

  SECTION("Front Torque is Greater than upper limit") {
    testframe.data[0] = 0x9C;
    testframe.data[1] = 0x40;
    testframe.data[2] = 0x00;
    testframe.data[3] = 0x00;
    testframe.data[4] = 0x7F;
    testframe.data[5] = 0xFF;
    storeV = torqueframe(testframe);
    REQUIRE(fronttorque == 40000);
    REQUIRE(reartorque == 32767);
    REQUIRE(storeV == 1);
  }

  SECTION("Rear Torque is Greater than upper limit") {

    testframe.data[0] = 0x7F;
    testframe.data[1] = 0xFF;
    testframe.data[2] = 0x00;
    testframe.data[3] = 0x00;
    testframe.data[4] = 0x80;
    testframe.data[5] = 0x00;
    storeV = torqueframe(testframe);
    REQUIRE(fronttorque == 32767);
    REQUIRE(reartorque == 32768);
    REQUIRE(storeV == 1);
  }
}

TEST_CASE("Checking the Maximum torque for the different wheel speed values") {
  SECTION("Checking the value for Wheelspeeds Greater than 700") {
    frontleftspeed = 800;
    frontrightspeed = 650;
    rearleftspeed = 750;
    rearrightspeed = 600;
    currentcal();
    REQUIRE(maxtorquefront == 50);
    REQUIRE(maxtorquerear == 50);
  }

  SECTION("Checking the value for Wheelspeeds Greater than 600") {
    frontleftspeed = 500;
    frontrightspeed = 650;
    rearleftspeed = 550;
    rearrightspeed = 640;
    currentcal();
    REQUIRE(maxtorquefront == 85);
    REQUIRE(maxtorquerear == 85);
  }

  SECTION("Checking the value for Wheelspeeds Greater than 500") {
    frontleftspeed = 550;
    frontrightspeed = 450;
    rearleftspeed = 580;
    rearrightspeed = 440;
    currentcal();
    REQUIRE(maxtorquefront == 100);
    REQUIRE(maxtorquerear == 100);
  }

  SECTION("Checking the value for Wheelspeeds Greater than 400") {
    frontleftspeed = 350;
    frontrightspeed = 450;
    rearleftspeed = 380;
    rearrightspeed = 440;
    currentcal();
    REQUIRE(maxtorquefront == 120);
    REQUIRE(maxtorquerear == 120);
  }

  SECTION("Checking the value for Wheelspeeds Greater than 300") {
    frontleftspeed = 350;
    frontrightspeed = 250;
    rearleftspeed = 380;
    rearrightspeed = 240;
    currentcal();
    REQUIRE(maxtorquefront == 150);
    REQUIRE(maxtorquerear == 150);
  }

  SECTION("Checking the value for Wheelspeeds Smaller than 300") {
    frontleftspeed = 150;
    frontrightspeed = 250;
    rearleftspeed = 180;
    rearrightspeed = 240;
    currentcal();
    REQUIRE(maxtorquefront == 32767);
    REQUIRE(maxtorquerear == 32767);
  }
}

TEST_CASE("Checking the Maximum allowed torque for the battery voltage less "
          "than 2.8 V") {
  testframe.data[0] = 0x00;
  testframe.data[1] = 0x02;
  storeV = batteryframe(testframe);
  currentcal();
  REQUIRE(maxtorquefront == 20);
  REQUIRE(maxtorquerear == 20);
}
